/**
 * Returns whether the given error object is an AbortError (generated by an AbortSignal aborting).
 */
export function isAbortError(err: any): boolean {
  return err instanceof Error && err.name === 'AbortError'
}

class AbortError extends Error {
  constructor() {
    super('Aborted')
    this.name = 'AbortError'
  }
}

/**
 * Races a given Promise against an `AbortSignal` becoming aborted, returning a Promise that will
 * either resolve/reject with the resolution of the Promise, or an `AbortError`, whichever happens
 * first.
 *
 * @see Promise.race
 */
// Implementation mostly from:
// https://github.com/whatwg/dom/issues/946#issuecomment-845906896
export async function raceAbort<T>(signal: AbortSignal, promise: Promise<T>): Promise<T> {
  if (signal.aborted) throw new AbortError()

  let onAbort: () => void | undefined
  return Promise.race([
    promise,
    new Promise<T>((_, reject) => {
      onAbort = () => reject(new AbortError())
      signal.addEventListener('abort', onAbort)
    }),
  ]).finally(() => signal.removeEventListener('abort', onAbort))
}

/**
 * A manager that references a number of `AbortSignal`s and only aborts if all of the signals have
 * aborted. This is intended for use in cases where multiple outstanding requests for the same data
 * are coalesced onto the original request.
 *
 * The `AbortSignal` reason will be set to the reason of the last signal that aborted.
 */
export class BatchedAbortSignals {
  private signals = new Set<AbortSignal>()
  private controller = new AbortController()

  constructor(initialSignal?: AbortSignal) {
    this.add(initialSignal)
  }

  add(signal?: AbortSignal) {
    const addedSignal = signal ?? new AbortController().signal
    addedSignal.addEventListener('abort', () => this.onAbort(addedSignal))
    this.signals.add(addedSignal)

    if (addedSignal.aborted) {
      queueMicrotask(() => this.onAbort(addedSignal))
    }
  }

  get signal() {
    return this.controller.signal
  }

  get aborted() {
    return this.controller.signal.aborted
  }

  private onAbort(signal: AbortSignal) {
    this.signals.delete(signal)
    if (this.signals.size === 0) {
      this.controller.abort(signal.reason)
    }
  }
}

/**
 * A helper class which allows you to use `BatchedAbortSignals` more easily. See the description
 * of that class for more info.
 */
export class RequestCoalescer {
  private requestsInProgress = new Map<unknown, BatchedAbortSignals>()

  async makeRequest(
    id: unknown,
    signal: AbortSignal | undefined,
    requestFn: (batchedSignal: AbortSignal) => Promise<void>,
  ): Promise<void> {
    let batchedSignals = this.requestsInProgress.get(id)
    if (batchedSignals && !batchedSignals.aborted) {
      batchedSignals.add(signal)
      return
    }

    batchedSignals = new BatchedAbortSignals(signal)
    this.requestsInProgress.set(id, batchedSignals)

    try {
      await requestFn(batchedSignals.signal)
    } finally {
      if (this.requestsInProgress.get(id) === batchedSignals) {
        this.requestsInProgress.delete(id)
      }
    }
  }
}
