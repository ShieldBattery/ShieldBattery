{
  "name": "routes",
  "description": "Minimalist route matching for javascript",
  "version": "1.1.0",
  "homepage": "https://github.com/aaronblohowiak/routes.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/aaronblohowiak/routes.js.git"
  },
  "author": {
    "name": "Aaron Blohowiak",
    "email": "aaron.blohowiak@gmail.com",
    "url": "http://github.com/aaronblohowiak"
  },
  "main": "dist/routes",
  "directories": {
    "lib": "."
  },
  "scripts": {
    "test": "make test",
    "prepublish": "mkdir -p dist/ && browserify --require ./index --standalone routes > dist/routes.js"
  },
  "engines": {
    "node": "*"
  },
  "devDependencies": {
    "browserify": "^3.30.4"
  },
  "readme": "# Routes.js\n\n`routes` lets you easily dispatch based on url-style strings.  It comes with a default `Router` function that you can use to route http requests, but it also cleanly exposes the important functionality so you could also use it to perform more generic string pattern matching.\n\nThis might make it useful for things like:\n\n* URI routing\n* Cucumber-style pattern matching :)\n* Routing messages by channel name from an MQ\n* Dispatching hierarchical events by name\n\n\n## Router Example:\n\nThe full range of `Path Formats` is documented below.\n\n```js\nvar Router = require('routes');\nvar router = Router();\nvar noop = function(){};\n\nrouter.addRoute(\"/articles/:title?\", noop);\nrouter.addRoute(\"/:controller/:action/:id.:format?\", noop);\n\nconsole.log(router.match(\"/articles\"));\nconsole.log(router.match(\"/articles/never-gonna-let-you-down\"));\nconsole.log(router.match(\"/posts/show/1.json\"));\n\n```\n\nThe output for `router.match(\"/posts/show/1.json\")` would be:\n```js\n{\n  params: {\n    controller: 'posts',\n    action: 'show',\n    id: '1',\n    format: 'json'\n  },\n  splats: [],\n  route: '/:controller/:action/:id.:format?',\n  fn: [Function],\n  next: [Function]\n}\n```\n\nIn the example above, `fn` would be the function that was passed into the router.\n\n\nI return this object instead of calling your function for you because you will likely want to add additional parameters from the current context to the function invocation. Ex:\n\n```js\nvar route = router.match(\"/posts/show/1.json\");\nroute.fn.apply(null, [req, res, route.params, route.splats]);\n```\n\n## Match Continuation\n\nThe object returned by `router.match` includes a `next` function you can use to continue matching against subsequent routes. Routes are evaluated in the order they are added to the router, so generally, you would add your most specific routes first and most ambiguous routes last. Using the `next` function allows you evaluate more ambiguous routes first.\n\n```js\nvar Router = require('routes');\nvar router = new Router();\n\nrouter.addRoute('/admin/*?', auth);\nrouter.addRoute('/admin/users', adminUsers);\n\nhttp.createServer(function (req, res) {\n  var path = url.parse(req.url).pathname;\n  var match = router.match(path);\n  match.fn(req, res, match);\n}).listen(1337)\n\n// authenticate the user and pass them on to\n// the next route, or respond with 403.\nfunction auth(req, res, match) {\n  if (checkUser(req)) {\n    match = match.next();\n    if (match) match.fn(req, res, match);\n    return;\n  }\n  res.statusCode = 403;\n  res.end()\n}\n\n// render the admin.users page\nfunction adminUsers(req, res, match) {\n  // send user list\n  res.statusCode = 200;\n  res.end();\n}\n```\n\n## Installation\n\n    npm install routes\n\n## Path Formats\n\nBasic string:\n\n    \"/articles\" will only match routes that == \"/articles\".\n\nNamed parameters:\n\n    \"/articles/:title\" will only match routes like \"/articles/hello\", but *not* \"/articles/\".\n\nOptional named parameters:\n\n    \"/articles/:title?\" will match \"/articles/hello\" AND \"/articles/\"\n\nPeriods before optional parameters are also optional:\n\n    \"/:n.:f?\" will match \"/1\" and \"/1.json\"\n\nSplaaaat! :\n\n    \"/assets/*\" will match \"/assets/blah/blah/blah.png\" and \"/assets/\".\n\n    \"/assets/*.*\" will match \"/assets/1/2/3.js\" as splats: [\"1/2/3\", \"js\"]\n\nMix splat with named parameters:\n\n    \"/account/:id/assets/*\" will match \"/account/2/assets/folder.png\" as params: {id: 2}, splats:[\"folder.png\"]\n\n\nNamed RegExp:\n\n    \"/lang/:lang([a-z]{2})\" will match \"/lang/en\" but not \"/lang/12\" or \"/lang/eng\"\n\nRaw RegExp:\n\n    /^\\/(\\d{2,3}-\\d{2,3}-\\d{4})\\.(\\w*)$/ (note no quotes, this is a RegExp, not a string.) will match \"/123-22-1234.json\". Each match group will be an entry in splats: [\"123-22-1234\", \"json\"]\n\n\n## Router API\n\nThe `Router()` that `routes` exposes has two functions: `addRoute` and `match`.\n\n`addRoute`: takes a `path` and a `fn`. Your `path` can match any of the formats in the \"Path Formats\" section.\n\n`match`: takes a `String` or `RegExp` and returns an object that contains the named `params`, `splats`, `route` (string that was matched against), the `fn` handler you passed in with `addRoute`, and a `next` function which will run `match` against subsequent routes.\n\n## Library API\n\n`match`: takes an array of `Routes`, and a `String`. It goes through `Routes` and returns an object for the first `Route` that matches the `String`, or `undefined` if none is found. The returned object contains `params`, `splats`, and `route`. `params` is an object containing the named matches, `splats` contains the unnamed globs (\"*\"), and `route` contains the original string that was matched against.\n\n`pathToRegExp`: takes a `path` string and an empty `keys` array, returns a RegExp and populates `keys` with the names of the match groups that the RegExp will match. This is largely an internal function but is provided in case someone wants to make a nifty string -> [RegExp, keys] utility.\n\n\n## Test\n\nClone the repo, cd to it, and:\n\n    make test\n\n## Credits\n\nThis library is an extraction and re-factor of the `connect` `router` middleware.  I found that connect-based routing worked reasonably well on the server side, but I wanted to do similar routing based on channel names when using `Push-It` and possibly for event names when using `Evan`.  So, I extracted the relevant goodness out of the `router` middleware and presented it here.  Big thanks to TJ Holowaychuk for writing the original `router` middleware.\n\n## License\n\nThis code is distributed under the MIT license, Copyright Aaron Blohowiak and TJ Holowaychuk 2011.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/aaronblohowiak/routes.js/issues"
  },
  "_id": "routes@1.1.0",
  "_shasum": "af3c2285a3f9d887ff0c14934fc54e1cf8f9b7ff",
  "_from": "routes@~1.1.0",
  "_resolved": "https://registry.npmjs.org/routes/-/routes-1.1.0.tgz"
}
